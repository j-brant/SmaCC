"
SmaCCParseNode is an abstract class that represents parse nodes generated by SmaCC.

Subclasses must implement the following messages:
	visitor-double dispatching
		acceptVisitor:

Instance Variables:
	attributes	<Dictionary>	a dictionary that holds special properties for each node
	parent	<SmaCCParseNode>	the parent node in the parse tree


"
Class {
	#name : #SmaCCParseNode,
	#superclass : #Object,
	#instVars : [
		'parent',
		'attributes'
	],
	#category : #'SmaCC_Runtime'
}

{ #category : #accessing }
SmaCCParseNode class >> collectionVariableIn: aSmaCCParseNode collectionGetter: aSymbol variableGetter: varSymbol [
	(aSmaCCParseNode respondsTo: aSymbol)
		ifTrue: [ ^ aSmaCCParseNode perform: aSymbol ].
	(aSmaCCParseNode respondsTo: varSymbol)
		ifTrue: [ ^ Array with: (aSmaCCParseNode perform: varSymbol) ].
	^ #()
]

{ #category : #accessing }
SmaCCParseNode class >> parserClass [
	"Return the parser class that likely created this node"

	| possibleClasses classNames topNodeClass |
	self == SmaCCParseNode
		ifTrue: [ ^ nil ].
	topNodeClass := self withAllSuperclasses
		detect: [ :each | each superclass = SmaCCParseNode ].
	classNames := (topNodeClass withAllSubclasses collect: #name) asSet.
	possibleClasses := SmaCCParser withAllSubclasses
		select: [ :each | 
			(each class includesSelector: #symbolTypes)
				and: [ each symbolTypes
						anySatisfy: [ :clsName | classNames includes: clsName ] ] ].
	possibleClasses size = 1
		ifTrue: [ ^ possibleClasses first ].
	^ nil
]

{ #category : #accessing }
SmaCCParseNode class >> variableIn: aSmaCCParseNode getter: aSymbol [
	(aSmaCCParseNode respondsTo: aSymbol)
		ifTrue: [ ^ aSmaCCParseNode perform: aSymbol ].
	^ nil
]

{ #category : #accessing }
SmaCCParseNode class >> visitorTrait [
	^ self == SmaCCParseNode
		ifTrue: [ TSmaCCParseNodeVisitor ]
		ifFalse: [ Smalltalk
				at: ('T' , self name , 'Visitor') asSymbol
				ifAbsent: [ superclass visitorTrait ] ]
]

{ #category : #comparing }
SmaCCParseNode >> = anObject [
	^ self == anObject
		or:
			[ self class = anObject class
				and:
					[ self variableSelectors
						allSatisfy:
							[ :symbol | 
							(self perform: symbol)
								allSatisfy: [ :each | (self perform: each) = (anObject perform: each) ] ] ] ]
]

{ #category : #'visitor-double dispatching' }
SmaCCParseNode >> acceptVisitor: aSmaCCParseNodeVisitor [
	^ aSmaCCParseNodeVisitor visitSmaCCParseNode: self
]

{ #category : #'collection handling' }
SmaCCParseNode >> addFirstNode: aSmaCCParseNode to: aCollection [
	aSmaCCParseNode isNil
		ifTrue: [ ^ self ].
	aCollection addFirst: aSmaCCParseNode.
	aSmaCCParseNode parent: self
]

{ #category : #'collection handling' }
SmaCCParseNode >> addFirstNodes: aSmaCCParseNodeCollection to: aCollection [
	aSmaCCParseNodeCollection isNil
		ifTrue: [ ^ self ].
	aSmaCCParseNodeCollection
		reverseDo: [ :each | self addFirstNode: each to: aCollection ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> addFirstObject: anObject to: aCollection [
	anObject isNil
		ifTrue: [ ^ self ].
	aCollection addFirst: anObject.
	(anObject isKindOf: SmaCCParseNode)
		ifTrue: [ anObject parent: self ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> addFirstObjects: addCollection to: aCollection [
	addCollection isNil
		ifTrue: [ ^ self ].
	addCollection
		reverseDo: [ :each | self addFirstObject: each to: aCollection ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> addFirstToken: aSmaCCToken to: aCollection [
	aSmaCCToken isNil
		ifTrue: [ ^ self ].
	aCollection addFirst: aSmaCCToken
]

{ #category : #'collection handling' }
SmaCCParseNode >> addFirstTokens: aSmaCCTokenCollection to: aCollection [
	aSmaCCTokenCollection isNil
		ifTrue: [ ^ self ].
	aCollection addAllFirst: aSmaCCTokenCollection
]

{ #category : #'collection handling' }
SmaCCParseNode >> addNode: aSmaCCParseNode to: aCollection [
	aSmaCCParseNode isNil
		ifTrue: [ ^ self ].
	aCollection add: aSmaCCParseNode.
	aSmaCCParseNode parent: self
]

{ #category : #'collection handling' }
SmaCCParseNode >> addNodes: aSmaCCParseNodeCollection to: aCollection [
	aSmaCCParseNodeCollection isNil
		ifTrue: [ ^ self ].
	aSmaCCParseNodeCollection
		do: [ :each | self addNode: each to: aCollection ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> addObject: anObject to: aCollection [
	anObject isNil
		ifTrue: [ ^ self ].
	aCollection add: anObject.
	(anObject isKindOf: SmaCCParseNode)
		ifTrue: [ anObject parent: self ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> addObjects: addCollection to: aCollection [
	addCollection isNil
		ifTrue: [ ^ self ].
	addCollection do: [ :each | self addObject: each to: aCollection ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> addToken: aSmaCCToken to: aCollection [
	aSmaCCToken isNil
		ifTrue: [ ^ self ].
	aCollection add: aSmaCCToken
]

{ #category : #'collection handling' }
SmaCCParseNode >> addTokens: aSmaCCTokenCollection to: aCollection [
	aSmaCCTokenCollection isNil
		ifTrue: [ ^ self ].
	aCollection addAll: aSmaCCTokenCollection
]

{ #category : #iterating }
SmaCCParseNode >> allGettersDo: aBlock [
	self allVariableSelectors
		do: [ :sel | (self perform: sel) do: aBlock ]
]

{ #category : #iterating }
SmaCCParseNode >> allNodesDo: nodeBlock [
	self allNodesDo: nodeBlock andTokensDo: nil
]

{ #category : #iterating }
SmaCCParseNode >> allNodesDo: nodeBlock andTokensDo: tokenBlock [
	self allNodesDo: nodeBlock andTokensDo: tokenBlock includeErrors: false
]

{ #category : #iterating }
SmaCCParseNode >> allNodesDo: nodeBlock andTokensDo: tokenBlock includeErrors: aBoolean [
	self
		nodesDo: [ :each | 
			nodeBlock value: each.
			each allNodesDo: nodeBlock andTokensDo: tokenBlock includeErrors: aBoolean ]
		andTokensDo: tokenBlock
		includeErrors: aBoolean
]

{ #category : #iterating }
SmaCCParseNode >> allNodesOfType: aClass do: nodeBlock [
	self
		allNodesDo: [ :each | 
			(each isKindOf: aClass)
				ifTrue: [ nodeBlock value: each ] ]
]

{ #category : #accessing }
SmaCCParseNode >> allParents [
	| parents |
	parent isNil
		ifTrue: [ ^ #() ].
	parents := OrderedCollection with: parent.
	[ parents last parent notNil ] whileTrue: [ parents addLast: parents last parent ].
	^ parents
]

{ #category : #accessing }
SmaCCParseNode >> allTokens [
	| tokens |
	tokens := OrderedCollection new.
	self allTokensInto: tokens.
	^ tokens
		asSortedCollection: [ :a :b | a startPosition < b startPosition ]
]

{ #category : #accessing }
SmaCCParseNode >> allTokensInto: aCollection [
	self tokenVariables
		do:
			[ :each | (self perform: each) ifNotNil: [ :token | aCollection add: token ] ].
	self compositeTokenVariables
		do:
			[ :each | 
			(self perform: each)
				ifNotNil: [ :tokens | aCollection addAll: tokens ] ].
	self nodesDo: [ :each | each allTokensInto: aCollection ]
]

{ #category : #tokens }
SmaCCParseNode >> allTokensMatching: aSmaCCToken [
	| tokens |
	tokens := OrderedCollection new.
	self
		allNodesDo: [ :each |  ]
		andTokensDo: [ :each | 
			each = aSmaCCToken
				ifTrue: [ tokens add: each ] ]
		includeErrors: true.
	^ tokens
]

{ #category : #variables }
SmaCCParseNode >> allVariableSelectors [
	^ #(#tokenVariables #compositeTokenVariables #nodeVariables #compositeNodeVariables #otherVariables #ignoredTokenVariables #ignoredCompositeTokenVariables #ignoredNodeVariables #ignoredCompositeNodeVariables #ignoredOtherVariables)
]

{ #category : #'accessing-attributes' }
SmaCCParseNode >> attributeNamed: aSymbol [
	attributes isNil
		ifTrue: [ ^ nil ].
	^ attributes at: aSymbol ifAbsent: [ nil ]
]

{ #category : #'accessing-attributes' }
SmaCCParseNode >> attributeNamed: aSymbol ifAbsent: aBlock [
	^ self attributes at: aSymbol ifAbsent: aBlock
]

{ #category : #'accessing-attributes' }
SmaCCParseNode >> attributeNamed: aSymbol ifAbsentPut: aBlock [
	^ self attributes at: aSymbol ifAbsentPut: aBlock
]

{ #category : #'accessing-attributes' }
SmaCCParseNode >> attributeNamed: aSymbol put: aValue [
	^ self attributes at: aSymbol put: aValue
]

{ #category : #'accessing-attributes' }
SmaCCParseNode >> attributes [
	^ attributes ifNil: [ attributes := IdentityDictionary new ]
]

{ #category : #private }
SmaCCParseNode >> calculateStartPosition [
	"Hackish way to get the minimum for all nodes. You might want to override to get a better implementation."

	| doBlock min |
	min := SmallInteger maxVal.
	doBlock := [ :each | each startPosition ifNotNil: [ :pos | min := min min: pos ] ].
	self nodesDo: doBlock andTokensDo: doBlock.
	^ min
]

{ #category : #private }
SmaCCParseNode >> calculateStopPosition [
	"Hackish way to get the maximum for all nodes. You might want to override to get a better implementation."

	| doBlock max |
	max := 0.
	doBlock := [ :each | each stopPosition ifNotNil: [ :pos | max := max max: pos ] ].
	self nodesDo: doBlock andTokensDo: doBlock.
	^ max
]

{ #category : #accessing }
SmaCCParseNode >> children [
	| result |
	result := OrderedCollection new.
	self
		nodesDo: [ :each | 
			each notNil
				ifTrue: [ result add: each ] ].
	^ result
]

{ #category : #'accessing-comments' }
SmaCCParseNode >> comments [
	^ self attributeNamed: #comments
]

{ #category : #'accessing-comments' }
SmaCCParseNode >> comments: anObject [
	self attributeNamed: #comments put: anObject
]

{ #category : #'accessing-comments' }
SmaCCParseNode >> commentsAfter [
	"Return the comments after this node and before the next node."

	^ self
		attributeNamed: #commentsAfter
		ifAbsentPut:
			[ self topParent comments
				ifEmpty: [ #() ]
				ifNotEmpty:
					[ :comments | 
					| startIndex stopIndex |
					startIndex := self stopPosition.
					stopIndex := self nodeAfter ifNil: [ SmallInteger maxVal ] ifNotNil: [ :node | node startPosition ].
					comments select: [ :each | each first > startIndex and: [ each last < stopIndex ] ] ] ]
]

{ #category : #'accessing-comments' }
SmaCCParseNode >> commentsBefore [
	"Return the comments before this node and after the previous node."

	^ self
		attributeNamed: #commentsBefore
		ifAbsentPut:
			[ self topParent comments
				ifEmpty: [ #() ]
				ifNotEmpty:
					[ :comments | 
					| startIndex stopIndex |
					startIndex := self nodeBefore ifNil: [ 1 ] ifNotNil: [ :node | node stopPosition ].
					stopIndex := self startPosition.
					comments select: [ :each | each first > startIndex and: [ each last < stopIndex ] ] ] ]
]

{ #category : #'accessing-comments' }
SmaCCParseNode >> commentsInside [
	"Return the comments inside the start/stop position for this node."

	^ self
		attributeNamed: #commentsInside
		ifAbsentPut:
			[ self topParent comments
				ifEmpty: [ #() ]
				ifNotEmpty:
					[ :comments | 
					| startIndex stopIndex |
					startIndex := self startPosition.
					stopIndex := self stopPosition.
					comments select: [ :each | each first > startIndex and: [ each last < stopIndex ] ] ] ]
]

{ #category : #source }
SmaCCParseNode >> completeSource [
	^ parent isNil
		ifTrue: [ self attributeNamed: #source ]
		ifFalse: [ parent completeSource ]
]

{ #category : #source }
SmaCCParseNode >> completeSource: aString [
	^ parent isNil
		ifTrue:
			[ (Smalltalk at: #SmaCCString ifAbsent: [ nil ])
				ifNotNil:
					[ :stringClass | self attributeNamed: #source put: (stringClass on: aString) ] ]
		ifFalse: [ parent completeSource: aString ]
]

{ #category : #variables }
SmaCCParseNode >> compositeNodeVariables [
	^ #()
]

{ #category : #variables }
SmaCCParseNode >> compositeTokenVariables [
	^ #()
]

{ #category : #variables }
SmaCCParseNode >> compositeVariableSelectors [
	^ #(#compositeTokenVariables #compositeNodeVariables #ignoredCompositeTokenVariables #ignoredCompositeNodeVariables)
]

{ #category : #variables }
SmaCCParseNode >> compositeVariables [
	^ self compositeVariableSelectors
		inject: Set new
		into:
			[ :sum :each | 
			sum
				addAll: (self perform: each);
				yourself ]
]

{ #category : #matching }
SmaCCParseNode >> convertToSetter: selector [
	^ (selector , ':') asSymbol
]

{ #category : #matching }
SmaCCParseNode >> copyInContext: aDictionary [
	| copy |
	copy := self copy.
	self tokenVariables
		do:
			[ :selector | 
			copy
				perform: (self convertToSetter: selector)
				with: ((self perform: selector) copyInContext: aDictionary) ].
	self nodeVariables
		do:
			[ :selector | 
			copy
				perform: (self convertToSetter: selector)
				with: ((self perform: selector) copyInContext: aDictionary) ].
	self compositeTokenVariables
		do:
			[ :selector | 
			copy
				perform: (self convertToSetter: selector)
				with:
					((self perform: selector)
						collect: [ :each | each copyInContext: aDictionary ]) ].
	self compositeNodeVariables
		do:
			[ :selector | 
			copy
				perform: (self convertToSetter: selector)
				with:
					((self perform: selector)
						collect: [ :each | each copyInContext: aDictionary ]) ].
	^ copy
]

{ #category : #source }
SmaCCParseNode >> deleteSource [
	self completeSource
		deleteFrom: self startPosition
		to: self stopPosition
]

{ #category : #source }
SmaCCParseNode >> deleteToken: aSmaCCToken [
	self completeSource
		deleteFrom: aSmaCCToken startPosition
		to: aSmaCCToken stopPosition
]

{ #category : #accessing }
SmaCCParseNode >> filename [
	^ self attributeNamed: #filename
]

{ #category : #accessing }
SmaCCParseNode >> filename: aString [
	self attributeNamed: #filename put: aString
]

{ #category : #'initialize-release' }
SmaCCParseNode >> fixParentPointers [
	self
		nodesDo: [ :each | 
			each parent: self.
			each fixParentPointers ]
]

{ #category : #testing }
SmaCCParseNode >> hasDescendant: aSmaCCNode [
	^ aSmaCCNode isDescendantFrom: self
]

{ #category : #testing }
SmaCCParseNode >> hasParentOfType: aSmaCCParseNodeClass [
	(parent isKindOf: aSmaCCParseNodeClass)
		ifTrue: [ ^ true ].
	^ parent notNil and: [ parent hasParentOfType: aSmaCCParseNodeClass ]
]

{ #category : #comparing }
SmaCCParseNode >> hash [
	^ self variableSelectors
		inject: self class hash
		into:
			[ :sum :symbol | 
			(self perform: symbol)
				inject: sum
				into:
					[ :hash :each | 
					| newHash |
					newHash := hash bitXor: (self perform: each) hash.
					((newHash bitShift: 1) bitAnd: SmallInteger maxVal)
						bitXor: (newHash bitShift: -29) ] ]
]

{ #category : #variables }
SmaCCParseNode >> ignoredCompositeNodeVariables [
	^ #()
]

{ #category : #variables }
SmaCCParseNode >> ignoredCompositeTokenVariables [
	^ #()
]

{ #category : #variables }
SmaCCParseNode >> ignoredNodeVariables [
	^ #()
]

{ #category : #variables }
SmaCCParseNode >> ignoredOtherVariables [
	^ #()
]

{ #category : #variables }
SmaCCParseNode >> ignoredTokenVariables [
	^ #()
]

{ #category : #source }
SmaCCParseNode >> insertSourceAfter: aString [
	self completeSource insert: aString at: self stopPosition + 1
]

{ #category : #source }
SmaCCParseNode >> insertSourceBefore: aString [
	self completeSource insert: aString at: self startPosition
]

{ #category : #source }
SmaCCParseNode >> insertSourceBefore: beginString andAfter: endString [
	self
		insertSourceBefore: beginString;
		insertSourceAfter: endString
]

{ #category : #testing }
SmaCCParseNode >> isDescendantFrom: aSmaCCNode [
	| current |
	current := self.
	[ current isNil or: [ current == aSmaCCNode ] ]
		whileFalse: [ current := current parent ].
	^ current notNil
]

{ #category : #testing }
SmaCCParseNode >> isErrorNode [
	^ false
]

{ #category : #testing }
SmaCCParseNode >> isListMatch [
	^ false
]

{ #category : #accessing }
SmaCCParseNode >> lookupNode: aBlock [
	| current |
	current := self.
	[ current isNil or: [ aBlock value: current ] ]
		whileFalse: [ current := current parent ].
	^ current
]

{ #category : #matching }
SmaCCParseNode >> match: aSmaCCParseNode inContext: aDictionary [
	self class = aSmaCCParseNode class
		ifFalse: [ ^ false ].
	(self
		matchVariables: self tokenVariables
		to: aSmaCCParseNode
		inContext: aDictionary)
		ifFalse: [ ^ false ].
	(self
		matchVariables: self nodeVariables
		to: aSmaCCParseNode
		inContext: aDictionary)
		ifFalse: [ ^ false ].
	(self
		matchCollectionVariables: self compositeTokenVariables
		to: aSmaCCParseNode
		inContext: aDictionary)
		ifFalse: [ ^ false ].
	^ self
		matchCollectionVariables: self compositeNodeVariables
		to: aSmaCCParseNode
		inContext: aDictionary
]

{ #category : #matching }
SmaCCParseNode >> matchCollection: matchNodes index: matchIndex to: programNodes index: programIndex inContext: aDictionary [
	| node currentIndex currentDictionary nodes |
	matchNodes size < matchIndex
		ifTrue: [ ^ programNodes size < programIndex ].
	node := matchNodes at: matchIndex.
	node isListMatch
		ifTrue:
			[ currentIndex := programIndex - 1.
			[ currentDictionary := aDictionary copy.
			programNodes size < currentIndex
				or:
					[ (self
						matchCollection: matchNodes
						index: matchIndex + 1
						to: programNodes
						index: currentIndex + 1
						inContext: currentDictionary)
						and:
							[ nodes := programNodes copyFrom: programIndex to: currentIndex.
							(node match: nodes inContext: currentDictionary)
								ifTrue:
									[ currentDictionary
										keysAndValuesDo: [ :key :value | aDictionary at: key put: value ].
									^ true ].
							false ] ] ] whileFalse: [ currentIndex := currentIndex + 1 ].
			^ false ].
	programNodes size < programIndex
		ifTrue: [ ^ false ].
	(node match: (programNodes at: programIndex) inContext: aDictionary)
		ifFalse: [ ^ false ].
	^ self
		matchCollection: matchNodes
		index: matchIndex + 1
		to: programNodes
		index: programIndex + 1
		inContext: aDictionary
]

{ #category : #matching }
SmaCCParseNode >> matchCollection: receiverCollection to: argumentCollection inContext: aDictionary [
	^ self
		matchCollection: receiverCollection
		index: 1
		to: argumentCollection
		index: 1
		inContext: aDictionary
]

{ #category : #matching }
SmaCCParseNode >> matchCollectionVariables: aCollection to: aSmaCCParseNode inContext: aDictionary [
	^ aCollection
		allSatisfy:
			[ :each | 
			self
				matchCollection: (self perform: each)
				to: (aSmaCCParseNode perform: each)
				inContext: aDictionary ]
]

{ #category : #matching }
SmaCCParseNode >> matchVariables: aCollection to: aSmaCCParseNode inContext: aDictionary [
	^ aCollection
		allSatisfy:
			[ :each | 
			| myValue otherValue |
			myValue := self perform: each.
			otherValue := aSmaCCParseNode perform: each.
			myValue isNil
				ifTrue: [ otherValue isNil ]
				ifFalse: [ myValue match: otherValue inContext: aDictionary ] ]
]

{ #category : #accessing }
SmaCCParseNode >> nodeAfter [
	| node stop |
	stop := self stopPosition.
	self topParent
		allNodesDo:
			[ :each | 
			each startPosition > stop
				ifTrue:
					[ node := node ifNil: [ each ] ifNotNil: [ node startPosition <= each startPosition ifTrue: [ node ] ifFalse: [ each ] ] ] ].
	^ node
]

{ #category : #accessing }
SmaCCParseNode >> nodeAt: anInteger [
	"Return inner most node whose sourceInterval overlaps anInteger or self if no nodes do."

	| node |
	self
		withAllNodesDo: [ :each | 
			(each startPosition > 0
				and: [ each startPosition <= anInteger and: [ each stopPosition >= anInteger ] ])
				ifTrue: [ node := each ] ]
		andTokensDo: [ :each |  ]
		includesErrors: true.
	^ node ifNil: [ self ]
]

{ #category : #accessing }
SmaCCParseNode >> nodeBefore [
	| node start |
	start := self startPosition.
	self topParent
		allNodesDo:
			[ :each | 
			each stopPosition < start
				ifTrue:
					[ node := node ifNil: [ each ] ifNotNil: [ node stopPosition > each stopPosition ifTrue: [ node ] ifFalse: [ each ] ] ] ].
	^ node
]

{ #category : #accessing }
SmaCCParseNode >> nodeOfType: aSmaCCParseNodeClassOrCollection [
	| isCollection |
	isCollection := aSmaCCParseNodeClassOrCollection isKindOf: Collection.
	^ self
		lookupNode:
			[ :each | 
			isCollection
				ifTrue:
					[ aSmaCCParseNodeClassOrCollection
						anySatisfy: [ :class | each isKindOf: class ] ]
				ifFalse: [ each isKindOf: aSmaCCParseNodeClassOrCollection ] ]
]

{ #category : #variables }
SmaCCParseNode >> nodeVariables [
	^ #()
]

{ #category : #iterating }
SmaCCParseNode >> nodesDo: nodeBlock [
	self nodesDo: nodeBlock andTokensDo: nil
]

{ #category : #iterating }
SmaCCParseNode >> nodesDo: nodeBlock andTokensDo: tokenBlock [
	self nodesDo: nodeBlock andTokensDo: tokenBlock includeErrors: false
]

{ #category : #iterating }
SmaCCParseNode >> nodesDo: nodeBlock andTokensDo: tokenBlock includeErrors: aBoolean [
	| block |
	nodeBlock notNil
		ifTrue: [ block := [ :each | (self perform: each) ifNotNil: nodeBlock ].
			self nodeVariables do: block.
			self ignoredNodeVariables do: block.
			block := [ :each | (self perform: each) ifNotNil: [ :nodes | nodes do: nodeBlock ] ].
			self compositeNodeVariables do: block.
			self ignoredCompositeNodeVariables do: block ].
	tokenBlock notNil
		ifTrue: [ block := [ :each | (self perform: each) ifNotNil: tokenBlock ].
			self tokenVariables do: block.
			self ignoredTokenVariables do: block.
			block := [ :each | (self perform: each) ifNotNil: [ :nodes | nodes do: tokenBlock ] ].
			self compositeTokenVariables do: block.
			self ignoredCompositeTokenVariables do: block ].
	block := [ :each | 
	nodeBlock notNil
		ifTrue: [ (each isKindOf: SmaCCParseNode)
				ifTrue: [ nodeBlock value: each ] ].
	tokenBlock notNil
		ifTrue: [ (each isKindOf: SmaCCToken)
				ifTrue: [ tokenBlock value: each ] ].
	(each isKindOf: Collection)
		ifTrue: [ each do: block ] ].
	self otherVariables do: [ :sel | block value: (self perform: sel) ].
	self ignoredOtherVariables do: [ :sel | block value: (self perform: sel) ]
]

{ #category : #variables }
SmaCCParseNode >> otherVariables [
	^ #()
]

{ #category : #accessing }
SmaCCParseNode >> parent [
	^ parent
]

{ #category : #accessing }
SmaCCParseNode >> parent: aSmaCCParseNode [
	parent := aSmaCCParseNode
]

{ #category : #accessing }
SmaCCParseNode >> parentOfType: aSmaCCParseNodeClassOrCollection [
	^ parent notNil
		ifTrue: [ parent nodeOfType: aSmaCCParseNodeClassOrCollection ]
		ifFalse: [ nil ]
]

{ #category : #accessing }
SmaCCParseNode >> parserClass [
	^ self class parserClass
]

{ #category : #copying }
SmaCCParseNode >> postCopy [
	super postCopy.
	self
		allGettersDo:
			[ :each | 
			self
				perform: (self convertToSetter: each)
				with:
					((self compositeVariableSelectors includes: each)
						ifTrue: [ (self perform: each) collect: [ :item | item copy ] ]
						ifFalse: [ (self perform: each) copy ]) ]
]

{ #category : #printing }
SmaCCParseNode >> printOn: aStream [
	super printOn: aStream.
	self topParent completeSource notNil ifTrue: [ 
		aStream 
			nextPut: $(;
			nextPutAll: (self topParent completeSource copyFrom: self startPosition to: self stopPosition) asString;
			nextPut: $) ]
]

{ #category : #'accessing-attributes' }
SmaCCParseNode >> removeAttributeNamed: aSymbol [
	attributes isNil
		ifTrue: [ ^ self ].
	attributes removeKey: aSymbol ifAbsent: [  ]
]

{ #category : #accessing }
SmaCCParseNode >> removePositions [
	self removeAttributeNamed: #startPosition.
	self removeAttributeNamed: #stopPosition
]

{ #category : #replacing }
SmaCCParseNode >> replace: originalSmaCCParseNode with: newSmaCCParseNode [
	SmaCCParseNode instSize + 1 to: self class instSize do:
		[ :i | 
		| each |
		each := self instVarAt: i.
		each == originalSmaCCParseNode
			ifTrue: [ self instVarAt: i put: newSmaCCParseNode ]
			ifFalse:
				[ (each isKindOf: SequenceableCollection)
					ifTrue:
						[ each
							keysAndValuesDo:
								[ :index :value | 
								value == originalSmaCCParseNode
									ifTrue: [ each at: index put: newSmaCCParseNode ] ] ] ] ].
	self completeSource
		ifNotNil:
			[ :source | 
			source
				replaceFrom: originalSmaCCParseNode startPosition
				to: originalSmaCCParseNode stopPosition
				with: newSmaCCParseNode source ].
	newSmaCCParseNode parent: self
]

{ #category : #source }
SmaCCParseNode >> replaceToken: aSmaCCToken withSource: aString [
	self completeSource
		replaceFrom: aSmaCCToken startPosition
		to: aSmaCCToken stopPosition
		with: aString
]

{ #category : #replacing }
SmaCCParseNode >> replaceWith: aSmaCCParseNode [
	parent replace: self with: aSmaCCParseNode
]

{ #category : #source }
SmaCCParseNode >> replaceWithSource: aString [
	^ self completeSource
		replaceFrom: self startPosition
		to: self stopPosition
		with: aString
]

{ #category : #private }
SmaCCParseNode >> safePerform: aSymbol [
	^ (self respondsTo: aSymbol)
		ifTrue: [ self perform: aSymbol ]
		ifFalse: [ nil ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> setParent: anObject to: parentNode [
	(anObject isKindOf: SmaCCParseNode)
		ifTrue: [ ^ (anObject parent == self or: [ anObject parent isNil ])
				ifTrue: [ anObject parent: parentNode ] ].
	(anObject isKindOf: OrderedCollection)
		ifTrue: [ anObject
				do: [ :each | 
					((each isKindOf: SmaCCParseNode)
						and: [ each parent == self or: [ each parent isNil ] ])
						ifTrue: [ each parent: parentNode ] ] ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> setParents: aCollection to: anObject [
	aCollection isNil
		ifTrue: [ ^ self ].
	aCollection do: [ :each | each parent: anObject ]
]

{ #category : #variables }
SmaCCParseNode >> singularVariableSelectors [
	^ #(#tokenVariables #nodeVariables #ignoredTokenVariables #ignoredNodeVariables #otherVariables #ignoredOtherVariables)
]

{ #category : #variables }
SmaCCParseNode >> singularVariables [
	^ self singularVariableSelectors
		inject: Set new
		into:
			[ :sum :each | 
			sum
				addAll: (self perform: each);
				yourself ]
]

{ #category : #accessing }
SmaCCParseNode >> sortedChildren [
	^ self children
		asSortedCollection:
			[ :a :b | 
			| startA startB |
			startA := a startPosition.
			startB := b startPosition.
			startA isNil
				or:
					[ b notNil
						and:
							[ startA class = startB class
								ifTrue: [ startA < startB ]
								ifFalse: [ startA class name < startB class name ] ] ] ]
]

{ #category : #source }
SmaCCParseNode >> source [
	^ self completeSource
		ifNotNil:
			[ :value | (value copyFrom: self startPosition to: self stopPosition) asString ]
]

{ #category : #accessing }
SmaCCParseNode >> sourceInterval [
	^ self startPosition to: self stopPosition
]

{ #category : #accessing }
SmaCCParseNode >> startPosition [
	^ self attributeNamed: #startPosition ifAbsentPut: [ self calculateStartPosition ]
]

{ #category : #accessing }
SmaCCParseNode >> stopPosition [
	^ self attributeNamed: #stopPosition ifAbsentPut: [ self calculateStopPosition ]
]

{ #category : #variables }
SmaCCParseNode >> tokenVariables [
	^ #()
]

{ #category : #accessing }
SmaCCParseNode >> topParent [
	| current |
	current := self.
	[ current parent notNil ] whileTrue: [ current := current parent ].
	^ current
]

{ #category : #variables }
SmaCCParseNode >> variableSelectors [
	^ #(#tokenVariables #compositeTokenVariables #nodeVariables #compositeNodeVariables #otherVariables)
]

{ #category : #accessing }
SmaCCParseNode >> visitorTrait [
	^ self class visitorTrait
]

{ #category : #iterating }
SmaCCParseNode >> withAllNodesDo: nodeBlock [
	nodeBlock value: self.
	self allNodesDo: nodeBlock
]

{ #category : #iterating }
SmaCCParseNode >> withAllNodesDo: nodeBlock andTokensDo: tokenBlock [
	self withAllNodesDo: nodeBlock andTokensDo: tokenBlock includesErrors: false
]

{ #category : #iterating }
SmaCCParseNode >> withAllNodesDo: nodeBlock andTokensDo: tokenBlock includesErrors: aBoolean [
	nodeBlock value: self.
	self allNodesDo: nodeBlock andTokensDo: tokenBlock includeErrors: aBoolean
]

{ #category : #iterating }
SmaCCParseNode >> withAllNodesOfType: aClass do: nodeBlock [
	(self isKindOf: aClass)
		ifTrue: [ nodeBlock value: self ].
	self allNodesOfType: aClass do: nodeBlock
]

{ #category : #accessing }
SmaCCParseNode >> withAllParents [
	| parents |
	parents := OrderedCollection with: self.
	[ parents last parent notNil ]
		whileTrue: [ parents addLast: parents last parent ].
	^ parents
]
